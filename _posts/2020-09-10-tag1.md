---
title: "Tag 1: Technische Grundlagen"
date: 2020-09-10
---

# Was währenddessen in der Welt geschieht
Zurzeit geht da seit Monaten so eine Pandemie um, vor der sich die Leute hüten sollen, vor allem diejenigen, die schon etwas älter sind, oder aber mit Personen zusammenleben, die zu den sogenannten Risikogruppen gehören. Nur so zum Kontext für Leute in der Zukunft, die vielleicht diesen Blog entdecken, es irgendwie dechifrieren können und wissen wollen, was die Leute im Jahre 2020 nach Christus Geburt so umgetrieben hat. 

# Start
Heute haben wir ein BAIN gestartet. Ist französisch für Bad. Nun, wir sind nicht ins kalte Bad gestossen worden, denn einiges davon, was man bei BAIN am ersten Tag machen sollen, haben wir ja schon in andere Module erlernt. Oder sollten es zumindest wieder im Kopf haben. Ich tendiere, Erinnerungsschwächen aufzuweisen, deswegen happerts bei mir mit dem Wiederaufrufen von gespeicherten Daten. Die Synapsen wollen einfach nicht so gut zusammenschliessen, wie sie es sollten, dünkt mich.

Der Unterricht hat online stattgefunden (und wird es immer tun). 

Wir haben gelernt, dass der Grossteil aller Server weltweit mit Linux laufen, und nicht mit Windows OS. Wir haben auch kurz etwas über sogenannte Harvester erfahren. Das sind irgendwelche Werkzeuge, die Daten von Informationsverwaltungsapplikation, wie z.B. ArchiveSpace, welches über eine Technik wie ein Open Archives Initiative Protocol for Metada Gathering (OAI-PMH) sammelt und es in andere gebräuchliche Metadaten umwandelt, wie z.B. EAD, oder Dublin Core, von dem ich schon ein paar Mal gehört habe. Zumindest interpretiere ich es so. 

Als Arbeitsumgebung soll man mit Linux arbeiten, und die Dozenten haben uns dafür virtuelle Rechenmaschinen bereitgestellt. Das bedeutet natürlich auch, sich wieder vertraut machen, wie die Linux-Befehle wieder gelautet haben. 
Auf Anhieb würde mir keines einfallen. Es ist aber glücklicherweise nicht so schwer, es anzuwenden. 

Es ist ausserdem ganz praktisch, dass uns Webseiten präsentiert wurden, wo man die wichtigeren Befehle wiederfinden kann. Die habe ich sogleich als Lesezeichen in Firefox abgelegt, unter dem Tag "linux list". Funktioniert aber nur in der virtuellen Rechenmaschine, nicht meinem eigentlichen physischen Hauptrechner. 

## Link zu Linux Befehlen
Es ist besser, ich stelle ein Verknüpfung zu dorthin, damit ich es unabhängig von der verwendeten Maschine auch wiederverwenden kann. 

```https://cheatography.com/davechild/cheat-sheets/linux-command-line/ ```

Hier ist ein anderer Link. 

```https://devhints.io/bash```

## Zurück zum Unterricht
Als weitere Anekdote haben wir erfahren, dass Systeme, welche Linux verwenden, generell eher nur die shell verwenden, anstatt graphische Benutzeroberlfächen wie bei Microsoft. Der Hauptgrund dafür sei, dass man auf graphische Elemente verzichten will, weil dies so die Informations-Technologie-Sicherheit erhöht. Und natürlich wird dadurch auch die Effizienz gesteigert, weil man nicht ständig ein Interface generieren muss, selbst wenn es für die Anwender einfacher wäre. 

wir haben dann Übungen gemacht, wie man Befehle für die linux-shell clever einsetzen könnte und erfahren, was wieder die Unterschiede zwischen Befehlen und Parameter sind. 
Interessant ist, dass wir ein gemeinsames Dokument verwenden, welches mit Markup formatiert wird. Das wird, soweit ich das weiss, auch bei Reddit verwendet. 
Im Gemeinsamen Dokument (ein CodiMD) kann jeder dort hineinschreiben, wenn man den Link dazu hat. MD steht wohl für MarkDown, wie ich vermute. Und wie ich lese, wird CodiMD bald seinen Namen umwechseln zu HedgeDoc (das ist jetzt mal Stand 10. September 2020). 

Abgespeichert wird dies alles auf github. Sieht für den Moment noch nicht so schön aus. Vielleicht werde ich da die Blog-Einträge dann noch nachträglich ändern. 

## Fazit
Ich bezweifle, dass ich Linux anwenden werde. Ich bin zu sehr ein graphisch orientierter Mensch, und bin es einfach zu sehr gewöhnt, mit Windows Benutzeroberflächen zu arbeiten. Wenn ich ein Resultat erwarte, will ich das visuell auch sehen, anstatt es in einer shell nachlesen zu müssen. Zumindest ist das meine jetzige Einstellung. 
